<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: linux[Linux] | My Octopress Blog]]></title>
  <link href="http://yoursite.com/blog/categories/linux-linux/atom.xml" rel="self"/>
  <link href="http://yoursite.com/"/>
  <updated>2014-01-01T01:02:39+08:00</updated>
  <id>http://yoursite.com/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[我们来打洞：转发DNS包]]></title>
    <link href="http://yoursite.com/blog/2013/01/07/foward-dns-packet-with-tunnel/"/>
    <updated>2013-01-07T06:22:44+08:00</updated>
    <id>http://yoursite.com/blog/2013/01/07/foward-dns-packet-with-tunnel</id>
    <content type="html"><![CDATA[<p>基于某些众所周知的原因，在天朝上网非常需要勇气和技术。
今天在跟某人聊天时了解到Chrome竟然没办法使用proxy进行DNS查询<1>， 导致DNS查询结果持续被污染。
虽然用proxychains能把一切流量塞进代理里面，
不过用proxychains启动浏览器的话，各种自动代理插件就失效了，所以这是个得不偿失的方法。
青蛙晚上的时候突然想到iptables是不是可以把DNS查询流量转发进ssh tunnel呢？
上网google一番之后，发现这是可行的，而且其实用不到iptables，只要nc就够了。</p>

<p>要用SSH Tunnel转发DNS流量，最大的问题是要把DNS协议使用的UDP协议转换为TCP协议，然后在proxy端还要转换回来。
所以目前青蛙想到的方案有一个很大的缺陷，就是如果ssh服务器上不提供nc命令的话，下面的操作是没法完成的。</p>

<p>首先，用SSH连接ssh服务器，这里青蛙打了一套组合拳，ssh -L + -D组合，分别负责DNS流量和普通数据流量：</p>

<pre><code>ssh -D1080 -L5353:127.0.0.1:5353 user@ssh-server
</code></pre>

<p>-L 参数的目的是在本地机器上打开一个5353端口，发送到这个端口的数据都会被转发到ssh服务器上的5353端口上。</p>

<p>然后，在ssh服务器上执行：</p>

<pre><code>server$ mkfifo /tmp/fifo
server$ nc -l -p 5353 &lt; /tmp/fifo | nc -u 8.8.8.8 53 &gt; /tmp/fifo
</code></pre>

<p>这两条命令用普通用户就可以执行，在大部分ssh服务器上应该都可以用。
另外<2>中还提供了一个socat版本，这个东东可以省去创建fifo管道的步骤，
看起来比较简洁，但是做的事情跟nc是一样的：
把ssh服务器上TCP5353端口收到的包转发到8.8.8.8的UDP53端口上去。</p>

<pre><code>socat tcp4-listen:5353,reuseaddr,fork UDP:8.8.8.8:53
</code></pre>

<p>接下来在本地机器上执行：</p>

<pre><code>local# mkfifo /tmp/fifo
local# sudo nc -l -u -p 53 &lt; /tmp/fifo | nc localhost 5353 &gt; /tmp/fifo
</code></pre>

<p>在本地UDP53端口上监听，一旦有数据包，就转发到本地的TCP5353端口上去。</p>

<p>socat版本：</p>

<pre><code>socat udp4-listen:53,reuseaddr,fork tcp:localhost:5353
</code></pre>

<p>好了，到此打洞的部分完成，最后的包转发流程应该是：</p>

<pre><code>localhost:UDP53 -&gt; localhost:TCP5353 -&gt; ssh-server:TCP5353 -&gt; 8.8.8.8:UDP53
</code></pre>

<p>主要就是使用nc/socat把UDP和TCP流量进行转换，以便可以把他们扔进SSH Tunnel里。</p>

<p>然后，修改/etc/resolv.conf：</p>

<pre><code>nameserver 127.0.0.1
</code></pre>

<p>这样再用Chrome浏览器就应该没有该死的DNS污染问题了。</p>

<p>这个解法不算太好，因为需要在Server端执行命令，如果是一些不给pty的host，就没办法用这个方法了。
可能比较好的方案还是透明代理之类的。</p>

<p>参考资料：</p>

<p><1>. Issue 29914: DNS queries not forwarded through SOCKS v5 proxies</p>

<p> <a href="https://code.google.com/p/chromium/issues/detail?id=29914">https://code.google.com/p/chromium/issues/detail?id=29914</a></p>

<p><2>. UDP traffic through SSH tunnel</p>

<p> <a href="http://superuser.com/questions/53103/udp-traffic-through-ssh-tunnel">http://superuser.com/questions/53103/udp-traffic-through-ssh-tunnel</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[procmail + kdialog 构建邮件提醒脚本]]></title>
    <link href="http://yoursite.com/blog/2011/10/10/procmail-kdialog-mail-notifyer/"/>
    <updated>2011-10-10T00:47:35+08:00</updated>
    <id>http://yoursite.com/blog/2011/10/10/procmail-kdialog-mail-notifyer</id>
    <content type="html"><![CDATA[<p>Mutt真的是神器，越用越觉得爽。可惜命令行模式的工具都有个弊端：跟X交互能力比较弱，例如Mutt就木有邮件提醒功能。之前在Gnome2的年代里还有<a href="http://www.nongnu.org/mailnotify/">mail-notification</a>可以对付用（这玩意占用系统资源狂多，似乎是通过监视文件更改来提醒的）,在Gnome3之后这个工具就完全不工作了，而且又没有后续版本。青蛙抛弃Gnome，换成KDE之后，也没有找到KDE下的邮件提醒工具，于是一直酝酿着自己写一个。</p>

<p>实现邮件提醒功能，无非就是监控邮箱变更，可以在几个点检查：</p>

<ul>
<li><p>直接使用POP/IMAP协议检查服务器端</p></li>
<li><p>监视MTA动作</p></li>
<li><p>监视MDA动作</p></li>
<li><p>监视MUA动作</p></li>
<li><p>监视邮箱文件/目录更改</p></li>
</ul>


<p>直接访问服务器是最直接的办法，但是既然MTA都把邮件收下来了，再去监视服务器就有点绕腾了，这种方法监视gmail/hotmail之类的邮箱还是很不错的。</p>

<p>监视MUA的动作，<a href="http://www.adam8157.info">adam8157</a>同学<a href="http://www.adam8157.info/blog/2010/05/mutt-filter-notify/">就是这么做的</a>，监视Mutt startusbar的特殊字符串，通过Mutt的filter发送notify消息。</p>

<p>监视邮箱文件/目录变化就是<a href="http://www.nongnu.org/mailnotify/">mail-notification</a>的做法了，但是如果不想轮询的话，大概需要内核开启inotify支持。</p>

<p>监视MTA动作，青蛙没有仔细研究，似乎还是需要MDA的某些行为处理，所以青蛙直接用了在MDA里加入提醒脚本的方法。</p>

<p>监视MDA动作，就是青蛙的做法，利用procmail的nested block，把邮件pipe到一个脚本中处理，提取邮件发送者、标题和内容，然后发notify。</p>

<p>消息提醒的脚本已经有人做好了：</p>

<p><a href="http://blargasm.com/post/7980037487/evolution-new-mail-notifier">http://blargasm.com/post/7980037487/evolution-new-mail-notifier</a></p>

<p>青蛙拿过来修改了一下，去掉pynotify，直接调用kdialog命令发送消息。</p>

<p>修改后的脚本在这里：</p>

<p><a href="http://code.google.com/p/gfrog/source/browse/mail/mail-notifier.py">http://code.google.com/p/gfrog/source/browse/mail/mail-notifier.py</a></p>

<p>脚本有了，然后修改~/.procmailrc，在需要监视的过滤规则里面加入</p>

<blockquote><p>:0</p>

<h1>Some filter rule</h1>

<p>{
:0 c
| ~/.mail-notifier.py
:0</p>

<h1>Here is your inbox</h1>

<p>Inbox
}</p></blockquote>

<p>这样就可以监视指定邮箱的新邮件啦：</p>

<p><img src="http://gfrog.net/wp-content/uploads/2011/10/mail-notify.png" alt="" /></p>

<p><strong>Update: 2012-06-11</strong>
由于这个提醒脚本最终是通过cron运行的，并且经过几次fork之后，它没法找到当前的dbus session了，于是导致kdialog 使用旧式的KPassivePopup现实消息，但是这玩意是hardcode了消息显示在屏幕中心，相当不爽。青蛙google了很久，终于还是捏着鼻子看了下kdialog的代码才发现问题。
更新：
<a href="https://code.google.com/p/gfrog/source/detail?r=fe8e9b57574529453fdb8655e0392260d39dcbfb">https://code.google.com/p/gfrog/source/detail?r=fe8e9b57574529453fdb8655e0392260d39dcbfb</a></p>

<p><strong>Update: 2012-06-11</strong>
继续更新，原始的mail notify脚本对于一些中文邮件subject和mail body的处理有问题，导致无法提醒中文邮件。目前青蛙的做法是把mail body当作utf-8字符串处理。当然这不能从根本上解决问题，只算是个workaround吧，还好青蛙的中文邮件不多。如果哪位读者遇到中文邮件还有问题，欢迎反馈bug。
同样，更新的代码在google code上：
<a href="https://code.google.com/p/gfrog/source/detail?r=3de26a63648944313893d74b94f54f28770bed30">https://code.google.com/p/gfrog/source/detail?r=3de26a63648944313893d74b94f54f28770bed30</a></p>

<p><strong>Update: 2011-10-14</strong>
青蛙今天忽然发现这个脚本处理某些邮件的时候发件人那部分是空的，调查一下发现时因为“email.Utils.parseaddr()”实际上是把发件人处理成名称和邮箱名的一个list，如果发件人没有名字，只有一个邮箱名的话，最后显示的发件人部分就是空白了。青蛙修改了一下脚本，仍然放在了google code上：</p>

<p><a href="https://code.google.com/p/gfrog/source/detail?r=0c64c067cf047ad4390bc2e57875cacf328999f1">https://code.google.com/p/gfrog/source/detail?r=0c64c067cf047ad4390bc2e57875cacf328999f1</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[配置wordpress的邮件发送功能]]></title>
    <link href="http://yoursite.com/blog/2010/12/23/enable-smtp-send-mail-in-wordpress/"/>
    <updated>2010-12-23T07:53:26+08:00</updated>
    <id>http://yoursite.com/blog/2010/12/23/enable-smtp-send-mail-in-wordpress</id>
    <content type="html"><![CDATA[<p>青蛙继续倒腾vps，今天的主题是调教wordpress发送邮件。</p>

<p>之前在Dreamhost上面，邮件系统已经配置好了，wordpress不需要任何设置就可以直接发送邮件。到了vps上之后，青蛙为了节省资源，没有安装邮件服务器，所以想要发送邮件，还需要自己折腾。
青蛙首先是想到了配置一个轻量级的MTA，例如msmtp之类的，然后修改php.ini的sendmail_path参数，使它指向msmtp。这样php程序就具有邮件发送能力了，但是这样产生的问题就是邮件的发送服务器是固定的，而且需要配置一个帐号来做登录服务器，如果某个用户希望使用自己的服务器发送某些邮件，这样配置就无法实现了。</p>

<p>为了实现完美的解决方案，青蛙又搜了一圈，发现了wordpress已经集成了一个PHPMailer[1]类，并且提供了一个wp_mail函数[2]来发送邮件，有很多设置SMTP的插件[3]方便我们配置SMTP服务器和外发邮件帐号信息。</p>

<p>青蛙选择了WP Mail SMTP插件，非常简单，把所有参数填好，wordpress就可以发送邮件了。</p>

<p>参考资料：
[1] PHPMailer <a href="http://phpmailer.worxware.com/">http://phpmailer.worxware.com/</a>
[2] Function Reference/wp_mail <a href="http://codex.wordpress.org/Function_Reference/wp_mail">http://codex.wordpress.org/Function_Reference/wp_mail</a>
[3] 让 WordPress 通过 SMTP 发送邮件 <a href="http://goto8848.net/2008/04/wordpress-mail-via-smtp/">http://goto8848.net/2008/04/wordpress-mail-via-smtp/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Install Xmind in Fedora with deb package]]></title>
    <link href="http://yoursite.com/blog/2010/12/22/install-xmind-in-fedora-with-deb-package/"/>
    <updated>2010-12-22T07:07:05+08:00</updated>
    <id>http://yoursite.com/blog/2010/12/22/install-xmind-in-fedora-with-deb-package</id>
    <content type="html"><![CDATA[<p><img src="http://gfrog.net/wp-content/uploads/2010/12/Install-Xmind-in-Fedora-with-deb-package.jpg" alt="Install-Xmind-in-Fedora-with-deb-package" /></p>

<p>原始文件地址： <a href="http://www.xmind.net/share/gfrog1/install-xmind-in-fedora-with-deb-package/">http://www.xmind.net/share/gfrog1/install-xmind-in-fedora-with-deb-package/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在NGINX上开启https]]></title>
    <link href="http://yoursite.com/blog/2010/12/18/setup-https-in-nginx/"/>
    <updated>2010-12-18T23:45:25+08:00</updated>
    <id>http://yoursite.com/blog/2010/12/18/setup-https-in-nginx</id>
    <content type="html"><![CDATA[<p>青蛙的新VPS是基于nginx的，仅仅是因为传言nginx在小内存，大压力的时候表现好一些。当然，为了获得这点好处，还是要付出一些代价的，例如nginx没有apache的htaccess，对每个目录的控制都需要写到nginx的配置文件中，这样对普通用户来说十分的不方便。</p>

<p>哦，有点跑题，继续说https的问题，其实给nginx配置https也不复杂，按照网上现成的模板，改一下自己的域名和目录位置就好了。</p>

<p>下面是一个完整的示例[1][2]：（来自<a href="http://sudone.com/nginx/nginx_ssl.html">这里</a>）</p>

<blockquote><p>upstream test.com {
server 192.168.1.2:80;</p></blockquote>

<p>}
server {
server_name test.com;
include port.conf;</p>

<p>ssl on;
ssl_certificate server.crt; # ${nginx_install_dir}/conf/server.crt
ssl_certificate_key server.key; # ${nginx_install_dir}/conf/server.key
error_page 497 &ldquo;<a href="https://$host$uri?$args">https://$host$uri?$args</a>&rdquo;;</p>

<p>location / {
proxy_pass <a href="http://test.com;">http://test.com;</a>
include proxy.conf;#
auth_basic &ldquo;status&rdquo;;
auth_basic_user_file trac.passwd;
}</p>

<p>}</p>

<p><strong>PS. </strong>按照<a href="https://blog.delphij.net/2010/07/nginxtlsssl.html">delphij大神的说法[3]</a>，nginx可以在一个IP上对使用不同证书的站点提供https支持。ubuntu上的nginx正好打开了这个支持。</p>

<p><strong>PS2.</strong> 有了https支持，青蛙就可以使用https方式打开wordpress后台了，也很简单，在wp-config.php里面加一句[4]：</p>

<blockquote><p>define(&lsquo;FORCE_SSL_ADMIN&rsquo;, true);</p></blockquote>

<p>参考资料：</p>

<p>[1] <a href="http://sudone.com/nginx/nginx_ssl.html">nginx ssl加密代理配置指南</a>
[2] <a href="http://zou.lu/nginx-https-ssl-module/">Nginx 配置 SSL 证书 + HTTPS 站点小记</a>
[3]<a href="https://blog.delphij.net/2010/07/nginxtlsssl.html">nginx中的TLS/SSL配置</a>
[4] <a href="http://www.wprecipes.com/how-to-force-using-ssl-on-wp-admin-directory">How to: Force using SSL on wp-admin directory</a></p>
]]></content>
  </entry>
  
</feed>
