
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Making Bootable Linux CDs - My Octopress Blog</title>
  <meta name="author" content="Your Name">

  
  <meta name="description" content="http://www.geocities.com/potato.geo/bootlinuxcd.html Introduction These are some discussion notes about my endeavours in creating a bootable CD. The &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://yoursite.com/old_post.before.2007/2005-05-22-making-bootable-linux-cds.html">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="My Octopress Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/lib/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">My Octopress Blog</a></h1>
  
    <h2>A blogging framework for hackers.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:yoursite.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
    <li><a href="/categories/gfrog-ride">骑行笔记</a></li>
    <li><a href="/categories/linux">Linux</a></li>
    <li><a href="/categories/picture">美丽图片</a></li>
    <li><a href="/categories/twitter-backup">Tweets</a></li>
    <li><a href="/blog/archives">全部日志</a></li>
    <li><a href="http://about.me/gfrog">关于我</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Making Bootable Linux CDs</h1>
    
    
      <p class="meta">
        








  


<time datetime="2005-05-22T23:57:33+08:00" pubdate data-updated="true">May 22<span>nd</span>, 2005</time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="http://www.geocities.com/potato.geo/bootlinuxcd.html">http://www.geocities.com/potato.geo/bootlinuxcd.html</a></p>

<p>Introduction</p>

<p>These are some discussion notes about my endeavours in creating a bootable CD. The main outcome of all this is my &lsquo;Pauls Boot CD&rsquo;. There is an atypical page describing it here.</p>

<p>Why put linux on a bootable CD? It means being able to take a useable linux system and start it on any PC you like without the pain of installing it all. You could use it as an install disk for a linux distribution or perhaps some other operating system. or you could make some sort of &lsquo;appliance&rsquo; out of it:</p>

<ul>
<li><p>MP3 player. You could burn all your MP3s plus a small bootable linux to turn your PC into a jukebox.</p></li>
<li><p>You could make your own &lsquo;Network Appliance&rsquo; that has the operating system and server software on CD, and use a hard disk for data storage only. It would mean you&rsquo;d never have to install an OS at all.</p></li>
<li><p>You could use it as a quick *nix toolkit. Just put enough on the CD to get networking and X windows going, start up Opera or netscape and you have a minimal graphical interface on a network. or put pppd on the CD and you can dial up an ISP ala an internet appliance.</p></li>
</ul>


<p>For other uses of bootable CDs have a look at ThinkNIC . Its a CD based Linux like thin client. DemoLinux is a distribution that only works on a CD.</p>

<p>This article outlines building a very general purpose &lsquo;base&rsquo; for building a bootable linux system &hellip; something that you can add to to create your own personal setup.</p>

<p>By the way, this is a major restructuring of an earlier document I wrote. You can find the old one here.</p>

<p>Research</p>

<p>Unfortunately, when I first started looking for information on the net, there didn&rsquo;t seem to be too much info about how to make bootable Linux CDs. After a bit more searching I&rsquo;ve found the following good references:</p>

<ul>
<li><p>RescueCD by Martin L. Purschke</p></li>
<li><p>Linux Appliance Construction Set by Michael W. Shaffer</p></li>
</ul>


<p>The standard for booting CDs is called &lsquo;El Torito&rsquo;. The concept is that your BIOS treats your CD like a floppy initially and expects to find the &lsquo;image&rsquo; of a bootable floppy on the CD. Your imaginary boot floppy is meant to have CDROM drivers on it which can somehow access the CD in full. This seemed overly complicated until I came across SysLinux. Its a boot loader that is part of Debian I think. It primarily is a floppy bootloader (like LOADLIN), but it now has an extra bit called ISOLINUX, that simplifies booting off a CD. The key benefit is that you no longer need a special floppy image. ISOLINUX will load the kernel and an initrd for you and away you go.</p>

<p>The boot process</p>

<p>The usual Linux boot process is something like:</p>

<ul>
<li><p>The PC starts up and runs LILO or some other bootloader</p></li>
<li><p>LILO knows where the kernel image is and starts to load it</p></li>
<li><p>The kernel runs. When its finished doing all its checks, it attempts to mount the root filesystem. The major and minor numbers for this device are usually encoded in the kernel itself or passed to it as arguments from LILO</p></li>
<li><p>Once the file system is mounted, /sbin/init is executed and your system starts up as per your inittab &hellip; and your /etc/rc*.d scripts</p></li>
</ul>


<p>The CD boot process is somewhat different. Again we need a boot loader, but we don&rsquo;t necessarily know what device our CDROM is. It could be /dev/hdb, /dev/hdc, /dev/hdd. Even if we told the boot loader where the kernel is, we would still need to tell the kernel where its root filesystem is. ISOLINUX helps us get around this, by working out where the CD is. This allows us to boot the kernel, but it doesn&rsquo;t really help us to load the initial root filesystem. Many boot disks use a thing called an initrd (Initial ram disk) to get around this. initrd is an initial root filing system running in RAM. It loads prior to when the kernel attempts to mount the &lsquo;real&rsquo; root file system. Yes this is odd. The idea is is that your initrd starts up, loads some critical modules, then mounts your real root file system.</p>

<p>Now have a look at my CD startup process.</p>

<ul>
<li><p>The CD is installed with ISOLINUX, so it boots first.</p></li>
<li><p>ISOLINUX loads the kernel from the /isolinux directory on the CD.</p></li>
<li><p>ISOLINUX now loads the initrd.gz compressed ext2 file system. Its important to note that ISOLINUX loads this, and not the kernel. The kernel will grab it later.</p></li>
<li><p>The kernel starts up and eventually decompresses the initrd.gz to ram (in /dev/ram0 actually) and mounts it as root. You have to enable INITRD and Ram disk support in the kernel to have this happen.</p></li>
<li><p>The kernel tries to execute the /linuxrc file in the new root filesystem (because its an &lsquo;initrd&rsquo;).</p></li>
<li><p>The linuxrc program tries to mount the CDROM (It has to make a few guesses to work out where it is), then copies a compressed &lsquo;real&rsquo; root filesystem from the CD into /dev/ram1. We mount the new filesystem just so we can add a softlink in its /dev directory for the CD (so we don&rsquo;t have to work out where the CD is again).</p></li>
<li><p>When the linuxrc script finishes, control returns to the kernel and it attempts to mount its configured root filesystem. In this case, I&rsquo;ve rdev&rsquo;d the kernel to make it use /dev/ram1 as the root filesystem. This will mount our newly created ram based root file system. In this file system I have an /sbin/init and the system starts up running entirely in RAM.</p></li>
</ul>


<p>So why does it have to be a two phase process? Linux doesn&rsquo;t really know how to boot off a CD yet. The beauty of the initrd phase is that the initrd filesystem is loaded by the bootloader (ie. not the kernel). It means that we can effectively boot off any device, so long as the bootloader is able to read from it.</p>

<p>Basic Requirements for building Bootable CDs</p>

<p>First, you&rsquo;re going to need a machine pre-installed with a Linux distribution to create the CD on. I&rsquo;m using Slackware 7.1 on a machine with a HP9100i CDwriter. I installed the cdrecord, mkisofs etc tools. I&rsquo;ve had to compile into the kernel all the necessary SCSI options to use the IDE CD-Writer (See the CD Writer HOWTO), plus I have loop file support compiled in. I&rsquo;d suggest you buy yourself a couple of blank CD-RWs to play with as you&rsquo;re going to be formatting, burning, trying it out &hellip; repeatedly.</p>

<p>You&rsquo;ll also need Syslinux. You need Nasm to build it. However, if you&rsquo;re too lazy to do this, all you need is the ISOLINUX.BIN file that is created.</p>

<p>Create a kernel for the CD</p>

<p>Now you need to create a kernel that can load the initrd. I&rsquo;ll assume you know how to build a kernel. All the experimentation here was done with a 2.2.18 kernel. You must compile in initrd support and RAM disk support. I am using the default 4096K RAM disk size. Other things that you&rsquo;ll need are ISO9660 filesystem support, ext2 filesystem support. Once you have this kernel, you need to set the root device on it:</p>

<p>eg. Say you&rsquo;ve just done a make bzImage</p>

<p>rdev /usr/src/linux/arch/i386/boot/bzImage /dev/ram1</p>

<p>NB: If you don&rsquo;t have a /dev/ram1 on your system, create one with:</p>

<p>mknod -m 640 /dev/ram1 b 1 1</p>

<p>Create a directory tree</p>

<p>You need a bit of template structure to work with. The layout I have is below:</p>

<p>The key directories are:</p>

<p>cdimage/ This is what mkisofs will use to write an image to the CD</p>

<p>initrd/ Holds the tree of our initrd filesystem</p>

<p>root/ Holds the tree of our real (final) root filesystem</p>

<p>If you download my bootkit, it lays everything out in this structure.</p>

<p>Setting u
p initrd</p>

<p>The INITRD phase has a simple goal ; Get a real root filesystem into /dev/ram1. I&rsquo;ve actually tried a lot of different alternative ways to do this. In order they are:</p>

<ol>
<li><p>Use a little shell script that uses the ash shell to mount the CD, gunzip a rootfs.gz file directly into /dev/ram1 and exit. This requires libc, so the initrd.gz image is about 600k. This is the most straightforward approach &hellip; but the most wateful.</p></li>
<li><p>Use an i386 assembly language program as &lsquo;linuxrc&rsquo; to perform the same task except that I used an alternative compression/decompression algorithm as gunzip was too complex to implement in assembly. linuxrc ends up being about 1k!! and requires no external libraries. This ends up with an initrd.gz of about 10k.</p></li>
<li><p>Use a statically linked C program for linuxrc that uses the gunzip.c source from Busybox as a basis, so that we effectively perform the same task as the shell script. By statically linking with dietlibc the linuxrc actually ends up being smaller than a dynamically linked one against libc 2.1.3!. The total size of linuxrc is about 20k, and the initrd.gz is about 15k.</p></li>
</ol>


<p>The C based linuxrc is really the best option. Its still quite small and uses a &lsquo;standard&rsquo; for compressed files. Read about the asm one here, and the shell one here.</p>

<p>The basic sequence of events in the C program are as follows:</p>

<ul>
<li><p>Mount /proc</p></li>
<li><p>Open the /proc/ide/ide0/hda/media file. If it says &lsquo;cdrom&rsquo; inside it then we&rsquo;ve found our boot CD, otherwise try /proc/ide/ide0/hdb/media, then /proc&hellip;/ide1/hdc/&hellip; , then /proc&hellip;/ide1/hdd/&hellip; until we find the first CDROM drive. This undoubtedly limits us to bootable IDE CDROMs on the two standard internal chains.</p></li>
<li><p>Change directory to /dev and create a symlink for &lsquo;cdrom&rsquo; to the newly found CDROM device (eg. cdrom &mdash;> hdc).</p></li>
<li><p>Mount /dev/cdrom on /cdrom</p></li>
<li><p>Open /cdrom/rootfs.gz and extract it into /dev/ram1. It must be a gzip of a 4mb ext2 filesystem.</p></li>
<li><p>Mount /dev/ram1 on /ram</p></li>
<li><p>Change directory into /ram/dev and create the same symlink for the CDROM again.</p></li>
<li><p>Unmount /ram, /cdrom and /proc</p></li>
</ul>


<p>The last step is simply to exit. The kernel should now take over, and mount /dev/ram1 as /, and try to run /sbin/init.</p>

<p>The linuxrc.c source is here . To compile it you should get dietlibc . Version 0.9 has a &lsquo;diet&rsquo; command that simplifies compiling programs using the new library. You should be able to compile linuxrc.c using: diet gcc -o linuxrc linuxrc.c</p>

<p>The &lsquo;Real&rsquo; root filesystem</p>

<p>You can&rsquo;t do too much with an initrd only system. You really need to create a useable root filesystem. Again, I&rsquo;m using a 4mb RAM disk, so its a bit of a squeeze (why didn&rsquo;t I go for a bigger RAM disk? I just hate wasting space, and I wanted this to be useable on machines with 16mb of ram or more). I chose Busybox to provide most of my /bin tools. In 0.51 of Busybox, you even get things like vi and wget. Its getting fatter at 250Kb or so these days with every tool compiled in (NB: You can reduce its code size by editing Config.h and commenting out the defines for the tools you don&rsquo;t want), but 250K is fine for our 4mb filesystem. I&rsquo;ve put some libraries in too:</p>

<p>ld-2.1.3.so</p>

<p>ld-linux.so.2 &ndash;> ld-2.1.3.so</p>

<p>libbz2.so.1.0 &ndash;> libbz2.so.1.0.0</p>

<p>libbz2.so.1.0.0</p>

<p>libc-2.1.3.so</p>

<p>libc.so.6 &ndash;> libc-2.1.3.so</p>

<p>libcom_err.so.2 &ndash;> libcom_err.so.2.0</p>

<p>libcom_err.so.2.0</p>

<p>libdl-2.1.3.so</p>

<p>libdl.so.2 &ndash;> libdl-2.1.3.so</p>

<p>libe2p.so.2 &ndash;> libe2p.so.2.3</p>

<p>libe2p.so.2.3</p>

<p>libext2fs.so.2 &ndash;> libext2fs.so.2.4</p>

<p>libext2fs.so.2.4</p>

<p>libm-2.1.3.so</p>

<p>libm.so.6 &ndash;> libm-2.1.3.so</p>

<p>libncurses.so.5 &ndash;> libncurses.so.5.0</p>

<p>libncurses.so.5.0</p>

<p>libtermcap.so.2 &ndash;> libtermcap.so.2.0.8</p>

<p>libtermcap.so.2.0.8</p>

<p>libuuid.so.1 &ndash;> libuuid.so.1.2</p>

<p>libuuid.so.1.2</p>

<p>Not all of these are really required to get the system up and running. I think some are left over from when I had mke2fs. /bin is just busybox and a sh*#load of soft links. I have an /sbin/init (not linked to busybox, its a real sysvinit). In /etc I have an inittab, termcap and an rc.d directory. Currently I just have an rc.S startup script that is run during the sysinit phase of the init startup. The key parts of my inittab are:</p>

<p>id:1:initdefault:</p>

<p>si::sysinit:/etc/rc.d/rc.S</p>

<p>c1:1235:respawn:/bin/sulogin /dev/tty1</p>

<p>By using sulogin on the console, I force the user to enter a password (just a space), with the benefit that root&rsquo;s shell starts up in a normal login environment (ie. /etc/profile is run followed by ~/.profile)</p>

<p>/etc/fstab looks like:</p>

<p>/dev/ram1 / ext2 defaults 1 1</p>

<p>none /dev/pts devpts gid=5,mode=620 0 0</p>

<p>none /proc proc defaults 0 0</p>

<p>I also have an empty /initrd directory. This means that once that the initrd phase has finished, and the real root filesystem on /dev/ram1 is mounted, the initrd filesystem (on /dev/ram0) is moved under /initrd. This means we can unmount it and free the ramdisk space.</p>

<p>My /etc/rc.d/rc.S script looks like:</p>

<h1>!/bin/sh</h1>

<p>PATH=/bin;export PATH</p>

<p>echo &ldquo;System init&rdquo;</p>

<p>mount -t proc none /proc</p>

<p>mount -o remount,rw /</p>

<p>echo &ldquo;Find the extras on the CD and mount it&rdquo;</p>

<p>if [ -r /dev/cdrom ] ; then</p>

<p>mount -t iso9660 /dev/cdrom /cdrom</p>

<p>mount /dev/hda9 /a</p>

<p>fi</p>

<p>fi</p>

<p>cd /</p>

<p>umount /initrd</p>

<p>freeramdisk /dev/ram0</p>

<p>First we mount /proc, and then remount / (remember we have a valid entry for / in /etc/fstab now) as read/write. Now we check if the /dev/cdrom device is there (it should have been created in the initrd phase), then mount the cd. I have a symlink from /usr (in the root filesystem) to /cdrom/usr. This means that you can add your own extra binaries and extra libraries on the CDROM under its own /cdrom directory. For additional testing, I also mount an ext2 partition on my harddisk as /a.</p>

<p>Burning a CD with a kernel , initrd and a rootfs</p>

<p>Now that we have a kernel, initrd structure and rootfilesystem structure, how do we get them onto the CD. Lets look at the basic structure of the CD (how it would look if you just mounted it as an iso9660 CD):</p>

<p>/rootfs.gz</p>

<p>/isolinux/</p>

<p>isolinux.cfg &ndash; the isolinux config file</p>

<p>isolinux.bin &ndash; the isolinux boot program</p>

<p>vmlinuz &ndash; our kernel with initrd support</p>

<p>initrd.gz &ndash; our initial ram disk</p>

<p>The isolinux.cfg file contains:</p>

<p>label linux</p>

<p>kernel vmlinuz</p>

<p>append initrd=initrd.gz</p>

<p>Its similar to a LILO config. The main things are the kernel name and the append string which includes the name of our initrd. The fact that its gzipped doesn&rsquo;t matter. the kernel will automatically decompress it later.</p>

<p>What about the initrd and rootfs? These are both 4mb files that have been compressed with gzip. The contents of the 4mb file is a valid ext2 filesystem. Here&rsquo;s how I create them, given that I have a directory on my hard disk with the structure of the initrd or rootfs:</p>

<p>BASE=/src/iso</p>

<p>SRC=$BASE/initrd</p>

<p>DEST=$BASE/cdimage/isolinux/initrd</p>

<p>dd if=/dev/zero of=$DEST bs=1k count=4096</p>

<p>losetup /dev/loop1 $DEST</p>

<p>mkfs -t ext2 -m 0 /dev/loop1</p>

<p>mount /dev/loop1 /mnt</p>

<p>cd $SRC</p>

<p>tar cf &ndash; . | (cd /mnt ; tar xf &ndash;
 )</p>

<p>umount /mnt</p>

<p>losetup -d /dev/loop1</p>

<p>gzip -f $DEST</p>

<p>To burn the CD, I have the cd tree shown above under my /src/iso/cdimage directory (.ie I have a /src/iso/cdimage/isolinux directory). I run mkisofs as per the isolinux.doc that comes with Syslinux:</p>

<p>mkisofs -o /iso.img -b isolinux/isolinux.bin -c isolinux/boot.cat</p>

<p>-no-emul-boot -boot-load-size 4 -boot-info-table -l</p>

<p>-R -r /src/iso/cdimage</p>

<p>The boot.cat file is created by the mkisofs command. The -l , -R and -r options are essentially for RockRidge extensions which allow us to have softlinks on the CD and mixed case filenames. We should end up with a couple of meg iso.img file. You can now burn this to the CD using cdrecord (I&rsquo;ll leave this up to you as your speed and dev settings are undoubtedly different to me).</p>

<p>Reboot your system, enter the BIOS setup screens to check that your system will boot off a CD and load the CD and see if it boots. Hopefully, you should see &lsquo;Loading vmlinuz&rsquo;, then &lsquo;Loading initrd.gz&rsquo;, then the kernel should do its stuff. You should end up with a &lsquo;please enter the root password&rsquo; message (just enter SPACE the ENTER). You should be able to cd and ls and so forth.</p>

<p>A basic image to try out</p>

<p>I&rsquo;ve uploaded a very basic ISO that you can burn to a CD and have a play with. It doesn&rsquo;t do too much as yet, but it has the full set of busybox 0.51 commands available and I&rsquo;ve added some scripts to simplify the setting up of your lan card and IP address details. To allow different LAN cards to be configured, I&rsquo;ve included all the modules for different LAN cards in the /modules directory of the CD.</p>

<p>First, download the iso.img.gz file. Decompress it with gunzip and burn it to a CD (I&rsquo;d suggest a CDRW) using cdrecord or if you want to do it from Windows, you probably just need to rename it to blah.iso and Easy CD Creator or whathaveyou should be able to burn it.</p>

<p>The CD contains my own initrd.gz and rootfs.gz. You can have a look at these by decompressing them and mounting them as ext2 filesystems on a loopback mount.</p>

<p>Reboot with the CD in your CD drive and you should get some ISOLINUX message and away it goes. I&rsquo;ve enabled framebuffer support, but you can select whether you want plain text or one of the graphical modes.</p>

<p>You&rsquo;ll get an sulogin prompt (please enter the root password or press ctrl-D), so enter the root password (a single space) and you should be at a bash prompt.</p>

<p>To configure your LAN card enter cfgcard and follow the prompts. The list of cards that is shown is simply the modules directory on the CD. Cards like 3c509 are obvious, but others are not. I have an rtl8139 based card which is the most common el-cheapo 10/100Mbps card you can buy.</p>

<p>Now do a cfglan which allows you to set the IP address, netmask and default gateway etc. It also asks you about nameservers and such as it creates a /etc/resolv.conf so name resolution will work.</p>

<p>Note: to keep the size of the ISO quite small, I have not included any X related stuff&hellip;. for now.</p>

<p>Framework for extensibility</p>

<p>or &hellip; how to add your own extra bits. As I said previously the /usr directory on the CD is symlinked in to become the actual /usr. Create a /usr/bin on the CD and add in all the tools that Busybox doesn&rsquo;t include. Add some libraries into /usr/lib &hellip; and what I&rsquo;ve been working on is the basic requirements to get X up and running. One thing to remember is that you really do have to run mkisofs with RockRidge extensions on in order for softlinks and mixed case filenames to be created properly on the CD.</p>

<p>Framebuffer</p>

<p>One of my experimental aims is to have an X windows environment on a boot CD. To achieve the widest possible compatibility, I&rsquo;ve chosen to enable the Framebuffer console mode and to use the XF86_FBDev X server (its just the one from Slackware 7.1 at the moment). Note: Even though I am aiming for wide compatibility just so I can run X, Framebuffer mode doesn&rsquo;t work with pre VESA 2.0 video cards which means you may not want to add in Framebuffer if all you really need is a console prompt. To activate Framebuffer console mode you need to make sure some things are compiled into the kernel, typically this includes:</p>

<ul>
<li>VGA text console</li>
<li>Video mode selection support</li>
<li>Support for frame buffer devices (EXPERIMENTAL)</li>
<li>VESA VGA graphics console</li>
<li>Advanced low level driver options</li>
</ul>


<p>&lt;*> 8 bpp packed pixels support</p>

<p>&lt;*> 16 bpp packed pixels support</p>

<p>&lt;*> 24 bpp packed pixels support</p>

<p>&lt;*> 32 bpp packed pixels support</p>

<p>&lt;*> VGA characters/attributes support
* Select compiled-in fonts
* VGA 8x8 font
* VGA 8x16 font</p>

<p>The other thing that I didn&rsquo;t realise until later is you have to make sure you set a graphical mode for the console when it boots in order to use the X server in default mode. This means putting a specific vga= setting appended to the kernel at boot time. Specifically, you need to change the /isolinux/isolinux.cfg file on the CD so it looks something like:</p>

<p>label linux</p>

<p>kernel vmlinuz</p>

<p>append initrd=initrd.gz vga=791</p>

<p>The &lsquo;791&rsquo; means to start up in 1024x768x16bit colour mode. Hard coding the display resolution is fine if you know for certain that your video card/monitor can handle it, but what I&rsquo;ve done is to let the user choose a display option at boot time. My isolinux.cfg looks like this:</p>

<p>timeout 30</p>

<p>prompt 1</p>

<p>display menu.txt</p>

<p>default 1</p>

<p>label 1</p>

<p>kernel vmlinuz</p>

<p>append initrd=initrd.gz</p>

<p>label 2</p>

<p>kernel vmlinuz</p>

<p>append initrd=initrd.gz vga=788</p>

<p>label 3</p>

<p>kernel vmlinuz</p>

<p>append initrd=initrd.gz vga=791</p>

<p>menu.txt is a simple text file that looks like:</p>

<p>1) Text Mode</p>

<p>2) 800x600 x 16bit colour</p>

<p>3) 1024x768 x 16bit colour</p>

<p>The user just enters &lsquo;1&rsquo; if they want text mode, 2 for 800x600 and so on.</p>

<p>Notes</p>

<ul>
<li>The isolinux.cfg file seems rather dodgy if I put something like:</li>
</ul>


<p>label linux</p>

<p>kernel vmlinuz</p>

<p>append initrd=initrd.gz root=/dev/ram</p>

<ul>
<li><p>but seems to work OK if I take out the root=/dev/ram and simply use rdev to set the root fs in the kernel to /dev/ram1. You can&rsquo;t make /linuxrc start init properly. It just keeps spitting out a &lsquo;Usage&rsquo; string. I think its because init is unable to start as pid 1.</p></li>
<li><p>mkisofs will only write 8.3 style uppercase only filenames by default. If you want filenames up to 31 chars long, then specify the -l option. If you want mixed case filenames you need to enable the Rock Ridge extensions with the -R option, and may want to use the -r option as well which assigns sensible user/group ownership to all files. You will definately need the -R option if you want to copy whole unix directory trees to the CD.</p></li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Your Name</span></span>

      








  


<time datetime="2005-05-22T23:57:33+08:00" pubdate data-updated="true">May 22<span>nd</span>, 2005</time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/linux-linux/'>linux[Linux]</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  <a href="//twitter.com/share" class="twitter-share-button" data-url="http://yoursite.com/old_post.before.2007/2005-05-22-making-bootable-linux-cds.html" data-via="" data-counturl="http://yoursite.com/old_post.before.2007/2005-05-22-making-bootable-linux-cds.html" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/01/01/2013-summary-and-2014-outlook/">2013年终总结及2014年新年目标</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/09/tour-of-qingdao-b/">青岛两日游（中）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/09/09/tour-of-qingdao-a/">青岛两日游（上）</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/07/06/outing-jiming-dak-in-hebei/">探访鸡鸣驿</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/06/13/pic-of-dsic/">一张流：大连造船厂</a>
      </li>
    
  </ul>
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - Your Name -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
